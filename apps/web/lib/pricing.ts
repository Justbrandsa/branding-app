import { prisma } from "./db"; type QuoteInput={productId:string;variantId:string;qty:number;method:string;attributes?:Record<string,any>;positions:string[]}; export async function getPriceQuote(input:QuoteInput){ const {qty,method}=input; const m=await prisma.brandingMethod.findUnique({where:{key:method},include:{prices:true,setupFees:true,feeMaps:true}}); if(!m||!m.enabled) throw new Error("Method not enabled"); const setup=m.setupFees[0]; if(!setup) throw new Error("No setup fee configured"); const baseRule=m.prices[0]; if(!baseRule) throw new Error("No per-unit price rule configured"); let perUnitAmount=Number(baseRule.perUnitAmount); const breaks:Array<{min:number;max?:number;mult:number}>=(baseRule.qtyBreaks as any)||[]; for(const b of breaks){const inRange=qty>=b.min && (b.max?qty<=b.max:true); if(inRange) perUnitAmount=perUnitAmount*(b.mult||1);} const perUnitFeeVariantGid=m.feeMaps.find(f=>f.type==="per_unit")?.variantGid; const setupFeeVariantGid=m.feeMaps.find(f=>f.type==="setup")?.variantGid; if(!perUnitFeeVariantGid||!setupFeeVariantGid) throw new Error("Fee SKU mapping missing"); return {currency:baseRule.currency||"ZAR",perUnitAmount:Number(perUnitAmount.toFixed(2)),setupFeeAmount:Number(setup.amount),perUnitFeeVariantGid,setupFeeVariantGid} as const; }
